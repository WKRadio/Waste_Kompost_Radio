declare name "Audio Information Processing Library";
declare author "Luca Spanedda";
declare author "Dario Sanfilippo";
declare version "1.0";
declare description "2023";
declare copyright "Copyright (C) 2023 Luca Spanedda <lucaspanedda1995@gmail.com>";
declare copyright "Copyright (C) 2023 Dario Sanfilippo <sanfilippo.dario@gmail.com>";
declare license "MIT license";

// Import the standard Faust Libraries
import("stdfaust.lib");


// REFERENCES 
// 1) https://www.dariosanfilippo.com/blog/2017/lookahead-limiting-in-pure-data/
// 2) https://www.cs.princeton.edu/courses/archive/spr05/cos579/DSP/DSP.html
// 3) https://fmipa.umri.ac.id/wp-content/uploads/2016/03/Udo-Zolzer-digital-audio-signal-processing.9780470997857.40435.pdf
// 4) https://users.iem.at/zmoelnig/publications/limiter/
// 5) https://www.hackaudio.com/digital-signal-processing/amplitude/peak-normalization/


//---------------------------------------------------------- BASIC FUNCTIONS ---
// limit in a range: maximum limit and minimum limit
limit(maxl, minl, x) = max(minl, min(maxl, x));

//----------------------------------------------------------------- MAX PEAK ---
// references: 1, 2
// Peak Max with IIR filter and max comparison
peakmax(x) = loop ~_
with{
    loop(y) = abs(x) , y : max;
};

//process = _ : peakmax;

//--------------------------------------------------- MAX PEAK NORMALIZATION ---
// references: 5
// Peak Max Normalization
fixedNorm(x) = 1 / (x : loop ~ _) * x
with{
    loop(y,z) = ( (y, abs(z) ) : max);
};

//process = _ * .2 : fixedNorm;

//--------------------------------------------------- PEAK ENVELOPE FOLLOWER ---
// references: 1, 2
// Peak Envelope Follower with t60 Decay
peakenvelope(t60, x) = abs(x) <: loop ~ _ * rt60(t60)
    with{
        loop(y,z) = y, z : max;
        rt60(t) = 0.001 ^ ((1/ma.SR) / t);
    };

//process = peakenvelope(10);

//---------------------------------------------- PEAK ENVELOPE NORMALIZATION ---
// Fixed Peak Normalization with Decay
peakNorm(seconds, x) = 1 / peakenvelope(seconds, x) * x;

process = peakNorm(10);

//----------------------------------------- MOVING AVERAGE ENVELOPE FOLLOWER ---
movingAverage(seconds, x) = x - x@(seconds * ma.SR) : 
    fi.pole(1.0) / (seconds * ma.SR);

//process = _ * 10 : movingAverage(1);

//------------------------------------------------------- MOVING AVERAGE RMS ---
movingAverageRMS(seconds, x) = sqrt(max(0, movingAverage(seconds, x ^ 2)));

//process = movingAverageRMS(1);

//----------------------------------------------- ATTACK DECAY - RMS AVERAGE ---
// references: 3
RMS(att,rel,x) = loop ~ _ : sqrt
    with {
        loop(y) = (1.0 - coeff) * x * x + coeff * y
            with {
                attCoeff = exp(-2.0 * ma.PI * ma.T / att);
                relCoeff = exp(-2.0 * ma.PI * ma.T / rel);
                coeff = ba.if(abs(x) > y, attCoeff, relCoeff);
            };
    };

// process = RMS(1, 1);

//-------------------------------------------------------------- PEAK HOLDER ---
/*
peakHolder(secondsPeriod, x) = y
    letrec {
        'y = ba.if(reset, abs(x), max(y, abs(x)));
    }
        with {
            reset = os.phasor(1, 1.0 / secondsPeriod) : \(x).(x < x');
        };
*/

// holdTime in Seconds
peakHolder(holdTime, x) = loop ~ si.bus(2) : ! , _
with {
    loop(timerState, outState) = timer , output
    with {
        isNewPeak = abs(x) >= outState;
        isTimeOut = timerState >= (holdTime * ma.SR - 1);
        bypass = isNewPeak | isTimeOut;
        timer = ba.if(bypass, 0, timerState + 1);
        output = ba.if(bypass, abs(x), outState);
    };
};

//process = _ : peakHolder(2);

//------------------------------------------------------- LOOKAHEAD LIMITING ---
// references: 1, 4
lookAheadLimiting(threshold,x) = (x : peakHolder(.1) : fi.lowpass(1, 500) :
    peakenvelope(.1)) : threshold / max(ma.EPSILON, _) : min(1.0) *
        (x @ ((2 / 1000) * ma.SR));

// process = _ * 1000 : lookAheadLimiting(.5);

//------------------------------------------------------------ PITCH TRACKER ---
// averaging function with 2pi time constant; t is the averaging time in seconds
avg(t, x) = y
    letrec {
        'y = x + alpha * (y - x);
    }
        with {
            alpha = exp((-2.0 * ma.PI * ma.T) / t);
        };

// zero-crossing indicator function
zeroCrossing(x) = (x * x') < 0;

// zero-crossing rate
zeroCrossingRate(t, x) = zeroCrossing(x) : avg(t);

// pitch tracker as zero-crossing rate of self-regulating lowpassed inputs
// we highpass the input to avoid infrasonic
// components to affect the measurements
// we then clip the lowpass cutoff to improve stability
pitchTracker(t, x) = loop ~ _
    with {
        loop(y) = fi.lowpass(4, max(80, y), xHighpassed) :
                  (zeroCrossingRate(t) * ma.SR * .5)
            with {
                xHighpassed = fi.highpass(1, 20, x);
            };
    };

//process = os.osc(1000) : pitchTracker(.5);

//---------------------------------------------------------------- LOCAL MAX ---
localMax(seconds, x) = loop ~ si.bus(4) : _ , ! , ! , !
with {
    loop(yState, timerState, peakState, timeInSamplesState) = 
        y , timer , peak , timeInSamples
    with {
        timeInSamples = ba.if(reset + 1 - 1', limit(1000, 0, seconds) * 
            ma.SR, timeInSamplesState);
        reset = timerState >= (timeInSamplesState - 1);
        timer = ba.if(reset, 1, timerState + 1);
        peak = max(abs(x), peakState * (1.0 - reset));
        y = ba.if(reset, peak', yState);
    };
};
 
// process = localMax(4);

//---------------------------------------------------------- SAMPLE AND HOLD ---
// SAH circuit
SAH(ph, y) = \(FB).( selector( ph : \(x).(x < x'), FB, y ) )~ _ ;
// SAH with internal trigger
SAH2(f, y) = \(FB).( selector( phasor(f) : \(x).(x < x'), FB, y ) )~ _ ;